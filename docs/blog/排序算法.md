# 各种内部排序算法的比较

| 排序方法     | 平均情况            | 最好情况     | 最坏情况   | 辅助空间     | 稳定性 |
| ------------ | ------------------- | ------------ | ---------- | ------------ | ------ |
| 冒泡排序     | O($n^{2}$)          | O(n)         | O($n^{2}$) | O(1)         | 稳定   |
| 直接选择排序 | O($n^{2}$)          | O(n)         | O($n^{2}$) | O(1)         | 稳定   |
| 直接插入排序 | O($n^{2}$)          | O(n)         | O($n^{2}$) | O(1)         | 稳定   |
| 希尔排序     | O(nlogn)~O($n^{2}$) | O($n^{1/3}$) | O($n^{2}$) | O(1)         | 不稳定 |
| 堆排序       | O(nlogn)            | O(nlogn)     | O(nlogn)   | O(1)         | 不稳定 |
| 归并排序     | O(nlogn)            | O(nlogn)     | O(nlogn)   | O(n)         | 稳定   |
| 快速排序     | O(nlogn)            | O(nlogn)     | O($n^{2}$) | O(logn)~O(n) | 不稳定 |


# 冒泡排序

**冒泡排序**：一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。稳定排序算法

时间复杂度 O(n2)，里层循环每趟比较第 j 项和第 j+1项，如果前项大于后项，则发生交换。缺点是每次比较后都可能发生交换，交换次数太多了，值从小到大。

![](https://gitee.com/idea360/oss/raw/master/images/bubble-sort.gif)

通俗概述：依次比较相邻两关键字，如果反序则立即发生交换，如果正序则继续比较下一个相邻项，双重嵌套循环实现

具体如何移动呢？我们先看一个例子

有8个数字组成一个无序数列{5,6,3,1,8,7,2,4},希望按照从小到大的顺序 对其进行排序。详细排序如下，第一轮排序结束，最大元素8冒泡排到最后。以此类推，下一轮7排序到倒数第二的位置...

**实现代码：**

```java
public class BubbleSort {
    // 利用双重循环，如果前一个数比后一个数大，则发生交换，每次比较都发生交换
    public static void sort(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 1; j < arr.length - i; j++) {
                if (arr[j-1] > arr[j]) {
                    swap(arr, j-1, j);
                }
            }
        }
    }
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public static void main(String[] args) {
        int[] arr=new int[]{5,6,3,1,8,7,2,4};
        sort(arr);
        System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8]
    }
}
```

# 选择排序

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

![](https://gitee.com/idea360/oss/raw/master/images/selection-sort.gif)

**代码实现**

```java
public class SelectionSort {

    public static void sort(int array[]){
        for (int i = 0; i < array.length; i++) {
            int minIndex = i; // 用来保存最小的索引,初始指向当前第i项
            for (int j = i; j < array.length; j++) {
                // 找到最小的数
                if (array[j] < array[minIndex]) {
                    //将最小数的索引保存
                    minIndex = j;
                }
            }
            // 交换元素。最小元素排在前边，依次递增
            int temp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = temp;
        }
    }

    public static void main(String[] args) {
        int[] arr=new int[]{5,6,3,1,8,7,2,4};
        sort(arr);
        System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8]
    }
}
```

# 插入排序

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。就像打扑克整理牌一样。

![](https://gitee.com/idea360/oss/raw/master/images/insertion-sort.gif)

**代码实现**

```java
public class InsertionSort {

    public static void sort(int[] arr) {
        // 第一个肯定是有序的，所以从第二个数开始遍历
        for (int i=1; i<arr.length; i++) {
            int current = arr[i]; // 取出第i个数，和前i-1个数比较，插入合适位置。
            int preIndex = i - 1; // 前一个数索引
            // 当发现小元素时，将已排序元素中所有大于它的后移一个单位
            while(preIndex >= 0 && arr[preIndex] > current) {
                arr[preIndex + 1] = arr[preIndex];
                preIndex--;
            }
            // 将目标元素插入到位移后留下的空位。最后一次交换结束后再自减运算，所以这里需要+1
            arr[preIndex + 1] = current;
        }
    }

    public static void main(String[] args) {
        int[] arr=new int[]{5,6,3,1,8,7,2,4};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```

# 快速排序

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

![](https://gitee.com/idea360/oss/raw/master/images/quick-sort.gif)


**代码实现**

```java
public class QuickSort {

    public static void sort(int[] arr, int startIndex, int endIndex) {
        // 递归结束条件: startIndex大于等于endIndex
        if (startIndex >= endIndex) {
            return;
        }
        //得到基准元素位置
        int pivotIndex = partition(arr, startIndex, endIndex);
        // 根据基准元素，分成2部分进行递归排序
        sort(arr, startIndex, pivotIndex-1);
        sort(arr, pivotIndex+1, endIndex);
    }

    // 分治(双边循环法)
    public static int partition(int[] arr, int startIndex, int endIndex) {
        // 取第一个位置的元素作为基准元素
        int pivot = arr[startIndex];
        int left = startIndex;
        int right = endIndex;

        while (left != right) {
            // 控制right指针比较并左移,找到第一个小于基准值的元素索引
            while (left < right && arr[right] > pivot) {
                right--;
            }
            // 控制left指针比较并右移, 找到第一个大于基准值的元素索引
            while (left < right && arr[left] <= pivot) {
                left++;
            }
            // 交换left和right指针所指向的元素
            if (left < right) {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
            }
        }

        // pivot和指针重合点交换
        arr[startIndex] = arr[left];
        arr[left] = pivot;

        return left;
    }

    public static void main(String[] args) {
        int[] arr=new int[]{5,6,3,1,8,7,2,4};
        sort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8]
    }
}
```

总结快速排序的思想：冒泡+二分+递归分治